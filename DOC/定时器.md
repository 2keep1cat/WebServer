# 在本项目中的作用
定期检测`非活跃`连接，关闭文件描述符，释放连接资源
```
非活跃：是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费
```
# 在本项目中的用法
## 1 概述
* `定时事件`为定期检测非活跃连接
* 服务器主循环为每一个连接创建一个`定时器`，并对每个连接进行定时。
* 另外，利用升序时间链表作为`定时器容器`将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。
```
定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源

定时器:是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。

定时器容器:是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。
```
## 2 SIGALRM信号

本项目中使用的是`SIGALRM`信号，具体的做法是
* 利用alarm函数周期性地触发SIGALRM信号
* 信号处理函数利用管道通知主循环
* 主循环接收到该信号后对升序链表上所有定时器进行处理
* 若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源
```
Linux下提供了三种定时的方法:

* socket选项SO_RECVTIMEO和SO_SNDTIMEO

* SIGALRM信号

* I/O复用系统调用的超时参数
```
可以看出，定时器处理非活跃连接模块主要分为两部分
1. `定时方法与信号通知流程`
2. `定时器及其容器设计与定时任务的处理`

## 3 定时方法与信号通知流程
### 3.1 定时方法参考[>>信号API<<](./appendix/信号API.md)

### 3.2 信号通知流程

* Linux下的信号采用的异步处理机制，信号处理函数和当前进程是两条不同的执行路线。
```
具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。
```
* `注意事项`：为避免信号竞态现象发生，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽快执行完毕。

* `可能出现的问题`：一般的信号处理函数需要处理该信号对应的逻辑，当该逻辑比较复杂时，信号处理函数执行时间过长，会导致信号屏蔽太久。

* `解决方案`：信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。
#### 3.2.1 统一事件源
统一事件源，是指将信号事件与其他事件一样被处理。
```
具体的，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值。
```
使用`I/O复用系统调用`来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来监测，从而实现统一处理。

#### 3.2.2 信号处理机制
每个进程之中，都存着一个表，里面存着每种信号所代表的含义，内核通过设置表项中每一个位来标识对应的信号类型。
<p align="center">
<img src="img/6.png" style="zoom:80%"/>
</p>

* 信号的接收

接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。

* 信号的检测, 进程陷入内核态后，有两种场景会对信号进行检测：
    
    * 进程从内核态返回到用户态前进行信号检测

    * 进程在内核态中，从睡眠状态被唤醒的时候进行信号检测

当发现有新信号时，便会进入下一步，信号的处理。

* 信号的处理

    * ( 内核 )信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。

    * ( 用户 )接下来进程返回到用户态中，执行相应的信号处理函数。

    * ( 内核 )信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。

    * ( 用户 )如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。

至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。



## 4 定时器及其容器设计与定时任务的处理
