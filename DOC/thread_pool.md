# 线程池（Thread Pool）
是一种并发编程中常用的技术，用于管理和重用线程。


## 基本概念
在应用程序启动时创建一定数量的线程，并将它们保存在线程池中。当需要执行任务时，从线程池中获取一个空闲的线程，将任务分配给该线程执行。当任务执行完毕后，线程将返回到线程池，可以被其他任务复用。

## 设计思想
为了避免频繁地创建和销毁线程的开销，以及控制并发执行的线程数量，从而提高系统的性能和资源利用率。

## 关键组成部分
* `线程池管理器（ThreadPoolExecutor）`：负责创建、管理和控制线程池。它负责线程的创建、销毁和管理，以及线程池的状态监控和调度任务。
* `工作队列（BlockingQueue）`：用于存储待执行的任务。当线程池中的线程都在执行任务时，新的任务会被放入工作队列中等待执行。
* `线程池线程（Worker Thread）`：实际执行任务的线程。线程池中会维护一组线程，这些线程可以被重复使用，从而避免了频繁创建和销毁线程的开销。

## pthread_create函数使用注意事项
首先看一下该函数的函数原型。
```C
#include <pthread.h>
int pthread_create (
    pthread_t *thread_tid, 
    const pthread_attr_t *attr,
    void * (*start_routine) (void *),
    void *arg);
```
参数1返回新生成的线程的id，参数2指向线程属性的指针,通常设置为NULL，参数3是处理线程函数的地址，参数4是传向该函数的参数

`函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为静态成员函数。`

### 若参数3为类成员函数，注意
pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为`(void *)`,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数`(void *)`不能匹配，不能通过编译。

静态成员函数就没有这个问题，里面没有this指针。

```
 1. 静态成员变量
 将类中的成员变量声明为static，则为静态成员变量，和一般的成员变量不同，无论建立多少这个类的对象，都只有一个该静态成员变量的拷贝，也就是说所有对象共享。静态成员变量在编译阶段对象都还没创建时就分配了内存空间，放在全局静态区。
 * 最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。
 * 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
 * 非静态成员变量不能在类外初始化。
 * 静态成员数据是共享的。
2. 静态成员函数
将类成员函数声明为static，则为静态成员函数。

* 静态成员函数可以直接访问静态成员变量，`不能直接访问普通成员变量`，但可以通过参数传递的方式访问。
* 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
* 静态成员函数`没有this指针`。非静态数据成员为对象单独维护，但`静态成员函数为共享函数`，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。
```
## 线程池分析
线程池的设计模式为半同步/半反应堆，其中反应堆具体为[Proactor事件处理模式](./服务器事件类别与处理模式.md)。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

### 线程池的类定义
[>>代码实现<<](../Code/thread_pool/thread_pool.h)

需要注意的是，线程处理函数和运行函数设置为私有属性。

[-->下一篇](./http连接处理.md)