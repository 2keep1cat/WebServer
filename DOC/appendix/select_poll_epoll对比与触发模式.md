## select/poll/epoll对比
### 调用函数

select和poll都是一个函数，epoll是一组函数

### 文件描述符数量

* select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐

* poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目

* epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效

### 将文件描述符从用户传给内核

* select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝

* epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上

### 内核判断就绪的文件描述符

* select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生

* epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。

* epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list

### 应用程序索引就绪文件描述符

* select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历

* epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可

### 工作模式

* select和poll都只能工作在相对低效的LT模式下

* epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 

### 应用场景

* 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll

* 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll

* 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

## ET、LT、EPOLLONESHOT
### LT水平触发模式
* 当文件描述符上的状态处于就绪状态时，会持续通知应用程序
* epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。
* 当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理
* 适用于需要一直处理文件描述符上的数据的场景，需要确保应用程序可以及时处理就绪的事件

### ET边缘触发模式
* 边缘触发是 epoll 的默认模式，当文件描述符上的状态发生变化时，只会通知一次
* epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件
* 必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain
* 适用于需要实时处理数据的场景，可以减少事件通知的次数，提高效率

### EPOLLONESHOT
* 当文件描述符上的事件被触发并通知应用程序后，该文件描述符将被设置为非活跃状态，除非重新调用 epoll_ctl 并重新设置事件，否则不会再次通知应用程序
* 用于避免多个线程同时处理相同的文件描述符，确保每个文件描述符只由一个线程处理

* 我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件